# USTORE - SignUp Entrypoint

```
// creating ustore directory
mkdir ustore

// change directory
cd ustore

//Creating swagger.yml file
touch swagger.yml

// creating go.mod file to track dependencies
go mod init ustore
```

Add signup entrypoint details in the swagger.yml file as shown below:
```
swagger: "2.0"
info:
  version: "1.0.0"
  title: "ustore"
host: "localhost:8080"
basePath: "/v1"
schemes:
  - "http"
consumes:
  - "application/json"
produces:
  - "application/json"

paths:
  /signup:
    post:
      description: 'To register a new user'
      operationId: "signup"
      tags:
      - "signup"
      parameters:
        - in: 'body'
          name: 'signup'
          description: 'signup model'
          required: true
          schema:
            $ref: '#/definitions/SignUp'
      responses:
        200:
          description: Successful registeration
          schema:
            $ref: '#/definitions/SignUpResponse'
        400:
          description: Bad Request
        404:
          schema:
            type: string
          description: User not found
        500:
          schema:
            type: string
          description: Server error
definitions:
  SignUp:
    type: object
    required: [email,first_name,password,username]
    properties:
      first_name:
        type: string
      middle_name:
        type: string
      last_name:
        type: string
      email:
        type: string
      username:
        type: string
      password:
        type: string
      profile_image:
        type: string
  SignUpResponse:
    type: object
    properties:
      success:
        type: boolean
      message:
        type: string
```

We will keep the go-swagger generated code in gen directory.
```
// creating gen directory
mkdir gen

// to store all generated code in gen file
swagger generate server -t gen -f ./swagger.yml --default-scheme http --exclude-main

// to install dependencies
go get -u -f ./gen/...
```

Thus to check the API, we create main.go file to start the server without implementing the signup api. It will help to just check the generated swagger entrypoint model and handler.
<b>cmd/ustore-server/main.go</b>
```
// Code generated by go-swagger; DO NOT EDIT.

package main

import (
	"log"
	"os"

	"ustore/gen/restapi"
	"ustore/gen/restapi/operations"

	"github.com/go-openapi/loads"
	flags "github.com/jessevdk/go-flags"
)

// This file was generated by the swagger tool.
// Make sure not to overwrite this file after you generated it because all your edits would be lost!

func main() {

	swaggerSpec, err := loads.Embedded(restapi.SwaggerJSON, restapi.FlatSwaggerJSON)
	if err != nil {
		log.Fatalln(err)
	}

	api := operations.NewEFoodAPI(swaggerSpec)
	server := restapi.NewServer(api)
	defer server.Shutdown()

	parser := flags.NewParser(server, flags.Default)
	parser.ShortDescription = "E-Food"
	parser.LongDescription = swaggerSpec.Spec().Info.Description
	server.ConfigureFlags()
	for _, optsGroup := range api.CommandLineOptionsGroups {
		_, err := parser.AddGroup(optsGroup.ShortDescription, optsGroup.LongDescription, optsGroup.Options)
		if err != nil {
			log.Fatalln(err)
		}
	}

	if _, err := parser.Parse(); err != nil {
		code := 1
		if fe, ok := err.(*flags.Error); ok {
			if fe.Type == flags.ErrHelp {
				code = 0
			}
		}
		os.Exit(code)
	}

	server.ConfigureAPI()

	if err := server.Serve(); err != nil {
		log.Fatalln(err)
	}

}
```

Now, To implement the signup entrypoint we need to create client to connect to database and store user details.
<b>db/mysql/client.go</b>
```
package mysql

import (
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
	"log"
)

type client struct {
	// this place can be used to initialize the auth client which can be used to talk to other micro-services
}

func NewClient() client {
	return client{}
}

func (b client) BuildSqlClient() *sql.DB {
	// sensitive info can be stored in "secrets.json" of GKE
	db, err := sql.Open("mysql", "simsim:MYpassword100@/ustore?parseTime=True")
	if err != nil {
		log.Fatal("error connecting DB : ", err.Error())
	}
	return db
}
```

The db layer is connected to the server layer but here we are implementing the db function direct in the service layer.
<b>service/service.go</b>
```
package service

import (
	"database/sql"
	"ustore/gen/models"
)

type ServiceInfoHandler interface {
	Registration(db *sql.DB, userInfo *models.SignUp) error
}

type service struct{}

func NewServiceInfoHandler() ServiceInfoHandler{
	return &service{}
}
```

<b>service/signup.go</b>
```
package service

import (
	"database/sql"
	"ustore/gen/models"
	"errors"
	"golang.org/x/crypto/bcrypt"
)


func (c *service) Registration(db *sql.DB, userInfo *models.SignUp) error {
	password := []byte(*userInfo.Password)

	// Hashing the password with the default cost of 10
	hashedPassword, err := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)
	if err != nil {
		return err
	}

	//	err := User.AddUser(db, userInfo)
	row, err := db.Exec(
		"INSERT into user (email, first_name, last_name, middle_name, password, profile_image, username) values (?,?,?,?,?,?,?)",
		userInfo.Email,
		userInfo.FirstName,
		userInfo.LastName,
		userInfo.MiddleName,
		hashedPassword,
		userInfo.ProfileImage,
		userInfo.Username,
	)
	if err != nil {
		return err
	}
	if count, _ := row.RowsAffected(); count != 1 {
		return errors.New("Error inserting row value")
	}
	return nil
}
```

The service layer functions are hitted by handlers as following:
<b>handlers/signup.go</b>
```
package handlers

import (
	"database/sql"
	"ustore/gen/models"
	"ustore/gen/restapi/operations/signup"
	"ustore/service"
	"fmt"
	"github.com/go-openapi/runtime/middleware"
	"strings"
)

type SignUp/*registerImpl*/ struct {
	dbClient            *sql.DB
	serviceInfoHandler service.ServiceInfoHandler
}

func NewSignUpHandler(db *sql.DB, serviceInfoHandler service.ServiceInfoHandler) signup.SignupHandler {
	return &SignUp{
		dbClient:            db,
		serviceInfoHandler : serviceInfoHandler,
	}
}

func (s *SignUp) Handle(params signup.SignupParams) middleware.Responder {
	err := s.serviceInfoHandler.Registration(s.dbClient, params.Signup)
	if err != nil {
		fmt.Println(err.Error())
		if strings.Contains(err.Error(), "Duplicate entry") {
			if strings.Contains(err.Error(), "username_UNIQUE") {
				return signup.NewSignupOK().WithPayload(&models.SignUpResponse{Success: false, Message: "Username already registered"})
			}
			if strings.Contains(err.Error(), "email_UNIQUE") {
				return signup.NewSignupOK().WithPayload(&models.SignUpResponse{Success: false, Message: "Email already registered"})
			}
		}
		return signup.NewSignupInternalServerError().WithPayload("Error registering user")
	}
	return signup.NewSignupOK().WithPayload(&models.SignUpResponse{Success: true, Message: "User Registered successfully"})

}
```

To call the api we need to edit the configureAPI function as following:
<b>ustore/gen/restapi/configure_ustore.go</b>
```
func configureAPI(api *operations.UstoreAPI) http.Handler {
	// configure the api here
	api.ServeError = errors.ServeError

	// Set your custom logger if needed. Default one is log.Printf
	// Expected interface func(string, ...interface{})
	//
	// Example:
	// api.Logger = log.Printf

	api.UseSwaggerUI()
	// To continue using redoc as your UI, uncomment the following line
	// api.UseRedoc()

	api.JSONConsumer = runtime.JSONConsumer()

	api.JSONProducer = runtime.JSONProducer()

	client := mysql.NewClient()
	db := client.BuildSqlClient()
	serviceInfoHandle := service.NewServiceInfoHandler()

	api.SignupSignupHandler = handlers.NewSignUpHandler(db, serviceInfoHandle)

	if api.SignupSignupHandler == nil {
		api.SignupSignupHandler = signup.SignupHandlerFunc(func(params signup.SignupParams) middleware.Responder {
			return middleware.NotImplemented("operation signup.Signup has not yet been implemented")
		})
	}

	api.PreServerShutdown = func() {}

	api.ServerShutdown = func() {}

	return setupGlobalMiddleware(api.Serve(setupMiddlewares))
}
```

Finally, the signup api is implemeted and require to install the dependencies.
```
// to add dependencies
go get ustore/db/mysql
go get ustore/service
```

#### Result
![](https://i.imgur.com/LpWBDGT.png)

![](https://i.imgur.com/UqRBYvg.png)
![](https://i.imgur.com/rUTTFZb.png)

